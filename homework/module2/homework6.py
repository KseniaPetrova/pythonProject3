# Дополнительное практическое задание по модулю: "Базовые структуры данных."
"""
Задание "Слишком древний шифр":
Вы отправились в путешествие на необитаемый остров и конечно же в очередной вылазке в джунгли вы попали в ловушку
местному племени (да-да, классика "Индиана Джонса").
К вашему удивлению, в племени были неплохие математики и по совместительству фантазёры.
Вы поняли это, когда после долгих блужданий перед вами появились ворота (выход из ловушки) с двумя каменными
вставками для чисел.
В первом поле камни с числом менялись постоянно (от 3 до 20) случайным образом, а второе было всегда пустым.

К вашему счастью рядом с менее успешными и уже неговорящими путешествинниками находился попирус, где были написаны
правила для решения этого "ребуса". (Как жаль, что они поняли это так поздно :( ).

Во вторую вставку нужно было написать те пары чисел друг за другом, чтобы число из первой вставки было кратно
сумме их значений.

Пример 1:
9 - число из первой вставки
18273645 - нужный пароль (1 и 8, 2 и 7, 3 и 6, 4 и 5 - пары; число 9 кратно сумме каждой пары)

Пример 2:
11 - число из первой вставки
11029384756 - нужный пароль (1 и 10, 2 и 9, 3 и 8, 4 и 7, 5 и 6 - пары; число 11 кратно сумме каждой пары)


К сожалению, у вас не так много времени, чтобы подбирать пароль вручную, шипы сверху уже движуться на вас
(обожаю клише), тем более числа в первой вставке будут попадаться случайно.

Составьте алгоритм, используя циклы, чтобы в независимости от введённого числа n (от 3 до 20) программа выдавала
нужный пароль result, для одного введённого числа.

"""


random_number = list(range(3, 21))  # создаст последовательность чисел от 3 до 20
print('Все ключи')
# # Решение через for
for i in random_number:
    pairs = []
    for j in range(1, 21):
        for k in range(1, 21):
            if i == j + k:
                pairs += [[j, k]]
        if len(pairs) > 1 and pairs[-1][0] == pairs[-2][-1]:  # проверка для нечётных [x, y][y, x]
            pairs.remove(pairs[-1])  # удалит последнюю записанную пару
            break
        if len(pairs) > 1 and pairs[-1][-1] == pairs[-1][-2]:  # Проверка для чётных [x, x]
            pairs.remove(pairs[-1])
            break
    pairs_str = ''.join(f'{a}{b}' for a, b in pairs)  # выводим из списка списков строку
    print(f'{i} - {pairs_str}')

#
#
#
# Тест обращения к списку списков
# lisy_ = [[60, 77], [1, 2, 3], [4, 5], [5, 4]]
# if sum(lisy_[-1]) == sum(lisy_[-2]):
#     print('true')
# if len(lisy_) > 2:
#     print('yes')
# if lisy_[-2][-1] == lisy_[-1][0]:
#     print('pip')


## Вариант получения ключа для одного заданного числа через for
# изменен основной код
# num = int(input("Введите число от 3 до 20: "))
# keys = []
# for i in range(1, num):
#     for j in range(i + 1, num):  # к i+1, чтобы исключить повторения чисел в паре.
#                                 # Есть i-1, то повторится последняя пара в обратном порядке.
#         if (i + j) == num:
#             keys += f'{i}{j}'
# print('К числу ', num, ' - код: ', *keys, sep='')




